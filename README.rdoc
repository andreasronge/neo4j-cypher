== neo4j-cypher {<img src="https://secure.travis-ci.org/andreasronge/neo4j-cypher.png" />}[http://travis-ci.org/andreasronge/neo4j-cypher]

A Ruby DSL for the Neo4j Cypher query language for both MRI and JRuby.
The JRuby neo4j-core gem's cypher dsl has been moved to this gem.

=== Docs

See {Neo4j Wiki Cypher}[https://github.com/andreasronge/neo4j/wiki/Neo4j::Core-Cypher]

See the rspecs ! (> 99% test coverage)


=== Random Examples

Notice the last value returned is the return value (if possible).
Matching relationships can be done with operators: <,>, -, and <=> or with the both, incoming and outgoing methods.

"START v1=node(3) MATCH v2 = (v1)-[:`r`]->(x) RETURN v2"

  Neo4j::Cypher.query do
    node(3) > :r > :x
  end


"START v2=node(1) MATCH (v2)-[v1:`knows`]->(other) WHERE v1.since > 1994 and other.name = "foo" RETURN other"

  Neo4j::Cypher.query do
    node(1) > (rel(:knows)[:since] > 1994) > (node(:other)[:name] == 'foo'); :other
  end


"START v2=node(1) MATCH (v2)-[v1:`friends`]->(v3) WHERE (v1.since = 1994) RETURN v3"

  Neo4j::Cypher.query do
    node(1).outgoing(rel(:friends).where{|r| r[:since] == 1994})
  end


"START v1=node(2,3,4,1) RETURN count(v1.property?"

  Neo4j::Cypher.query do
    node(2, 3, 4, 1)[:property?].count
  end

"START v1=node(42) MATCH (v1)-[:`favorite`]->(stuff)<-[:`favorite`]-(person) WHERE not((v1)-[:`friend`]-(person)) RETURN person.name,count(stuff) ORDER BY count(stuff) DESC"

  Neo4j::Cypher.query do
    node(42).where_not { |m| m - :friend - :person } > :favorite > :stuff < :favorite < :person
    ret(node(:person)[:name], count(:stuff).desc)
  end


== Complex Example

"START n=node(42) MATCH (n)-[r]->(m) WITH n,collect(type(r)) as out_types,collect(m) as outgoing MATCH (n)<-[r]-(m) RETURN n,outgoing,out_types,collect(m) as incoming,collect(type(r)) as in_types"

  Neo4j::Cypher.query do
    n = node(42).as(:n)
    r = rel('r')
    m = node(:m)
    rel_types = r.rel_type.collect
    end_nodes = m.collect

    n.with_match(rel_types.as(:out_types), end_nodes.as(:outgoing)) { |n, _, _| n < r < m } > r > m

    ret([n,
         :outgoing,
         :out_types,
         end_nodes.as(:incoming),
         rel_types.as(:in_types)])
 end


=== Co-Tagged Places - Places Related through Tags

Find places that are tagged with the same tags: Determine the tags for place x. What else is tagged the same as x that is not x."

"START place=node:node_auto_index(name = "CoffeeShop1") MATCH place-[:tagged]->tag<-[:tagged]-otherPlace RETURN otherPlace.name, collect(tag.name) ORDER By otherPlace.name desc"

Can be written like this:

  Neo4j::Cypher.query do
    other_place = node(:otherPlace)
    place = lookup('node_auto_index', 'name', 'CoffeeShop1').as(:place)
    place > rel(':tagged') > node(:tag) < rel(':tagged') < other_place
    ret other_place[:name].desc, node(:tag)[:name].collect
  end


Or in one line:

  Neo4j::Cypher.query do
    lookup('node_auto_index', 'name', 'CoffeeShop1') > rel(':tagged') > node(:tag).ret { |t| t[:name].collect } < rel(':tagged') < node(:otherPlace).ret { |n| n[:name].desc }
  end


== License

The neo4j-cypher gem is released under the {MIT license}[www.opensource.org/licenses/MIT]


